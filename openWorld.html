<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- CRITICAL CHANGE: Disables pinch and double-tap zoom on mobile browsers --><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Open World D-Pad Explorer</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&family=Press+Start+2P&family=Squada+One&family=Tiny5&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles for full screen and no scrolling */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; 
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: 'Pixelify Sans', 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* The Game Container (The Viewport) */
        #game-container {
            width: 100vw; 
            height: 100vh; 
            position: relative; 
            overflow: hidden;
            
            /* Camera/World Setup */
            background-image: url('bgs/openWorldBG01.png');
            background-size: 3000px 2000px; 
            background-repeat: no-repeat;
            background-position: 0px 0px; 
            transition: background-position 0.1s linear; /* Smooth scrolling effect */
        }

        /* The Character (Fixed in the Center of the viewport/camera) */
        #character {
            width: 80px; 
            height: 80px; 
            position: absolute; 
            /* Fixed position: Center of the screen (50% - half of 80px = 40px) */
            top: calc(50% - 40px); 
            left: calc(50% - 40px);
            image-rendering: pixelated; 
            z-index: 10;
        }

        /* NPC Avatar Styling */
        .npc-avatar {
            width: 80px;
            height: 80px;
            position: absolute; 
            z-index: 9; 
            image-rendering: pixelated; 
        }

        /* NEW: Structure/Building Styling */
        .structure-avatar {
            position: absolute; 
            z-index: 5; /* Behind NPCs and character */
            image-rendering: pixelated; 
        }

        /* --- 1. Dynamic NPC Interaction Bubble (Positioned absolutely inside container) --- */
        #interaction-bubble {
            position: absolute; 
            width: 180px;
            padding: 8px 12px;
            background-color: #e0f2fe; /* Light blue for dialogue */
            border: 2px solid #005f73; 
            border-radius: 8px;
            font-size: 0.85rem;
            color: #003049;
            text-align: center;
            z-index: 15; 
            box-shadow: 2px 2px 0px #003049; 
            opacity: 1;
            transition: opacity 0.3s ease-out;
            pointer-events: none; 
            transform: translateX(-50%); /* Center based on calculated JS position */
            /* New: Ensuring it's initially off-screen or hidden visually */
            top: -9999px; 
            left: -9999px;
        }

        #interaction-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px; 
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid #e0f2fe; 
            filter: drop-shadow(0 2px 0px #003049); 
        }

        /* --- 2. Boundary Warning Bubble (Fixed to the viewport edge) --- */
        #boundary-warning {
            position: fixed;
            padding: 10px 15px;
            background-color: #ffc200; /* Warning Yellow */
            color: #333;
            font-weight: bold;
            border: 2px solid #cc9900;
            border-radius: 4px;
            z-index: 25; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 1; 
            pointer-events: none;
        }

        /* Specific boundary positioning (updated by JS class) */
        .warning-top { top: 10px; left: 50%; transform: translateX(-50%); }
        .warning-bottom { bottom: 100px; left: 50%; transform: translateX(-50%); }
        .warning-left { left: 10px; top: 50%; transform: translateY(-50%); }
        .warning-right { right: 10px; top: 50%; transform: translateY(-50%); }


        /* Class to hide the NPC bubble */
        .hidden-bubble {
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        /* Class to hide the boundary bubble */
        .hidden-boundary {
            opacity: 0 !important;
        }


        /* D-Pad Controls (Overlay) */
        #controls {
            position: absolute;
            bottom: 120px; 
            left: 20px;
            z-index: 20;
            user-select: none; 

            /* D-Pad Grid Layout */
            display: grid;
            grid-template-areas:
                ". up ."
                "left center right"
                ". down .";
            grid-template-columns: repeat(3, 80px); 
            grid-template-rows: repeat(3, 80px); 
            gap: 2px;
        }

        #controls button {
            padding: 0;
            height: 100%;
            width: 100%;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            background-color: #4a7a88; 
            border: 3px solid #19282d;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 5px 0 #19282d;
            transition: all 0.05s ease;
        }

        #controls button:active {
            box-shadow: 0 1px 0 #19282d;
            transform: translateY(4px);
            background-color: #5bbdda;
        }

        /* Assign grid areas */
        #up-btn { grid-area: up; }
        #left-btn { grid-area: left; }
        #right-btn { grid-area: right; }
        #down-btn { grid-area: down; }

        /* Hidden element to fill the center of the D-Pad */
        .hidden-center { 
            grid-area: center; 
            visibility: hidden; 
            pointer-events: none;
        } 

        @media (max-width: 768px) {
            .bottom-nav {
                display: flex;
                /* Show for mobile */
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                /* UPDATED: Increased height to 70px */
                height: 80px;
                /* Set the background color */
                background-color: #4a7a88;
                box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                justify-content: space-around;
                align-items: center;

                /* MODIFIED: Changed margin to padding for empty space at the very bottom */
                padding-bottom: 10px;
            }

            .nav-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-decoration: none;
                color: white;
                /* Text color */
                flex-grow: 1;
                /* Retained flex-grow for side items */
                height: 100%;
                font-size: 0.75rem;
                /* Smaller font for mobile labels */
                transition: background-color 0.2s;
                background-color: transparent;
            }

            .nav-item:hover {
                background-color: #34495e;
            }

            .nav-item .icon {
                font-size: 1.5rem;
                line-height: 1;
                /* Keep icon vertically centered */
            }

            .nav-item .label {
                margin-top: 3px;
                font-family: 'Pixelify Sans', sans-serif;
            }

            /* REVISED CSS for the perfect circle orb icon */
            .bottom-nav .nav-item:nth-child(2) {
                /* Selects the second nav-item (the middle one) */
                position: relative;
                /* Adjusted top to keep the orb visually centered on the bar (70px high + 10px pad) */
                top: -20px;

                /* UPDATED: Orb size */
                width: 80px;
                height: 80px;
                border-radius: 15%;

                /* Ensures same color as navbar */
                background-color: #d9a56b;

                box-shadow: 0 -5px 10px rgba(0, 0, 0, 0.3);

                /* Overrides default nav-item flex properties to ensure fixed size */
                flex-grow: 0;
                flex-shrink: 0;
                flex-basis: auto;

                /* Margin adjustments to visually separate the side items from the orb */
                margin-left: 15px;
                margin-right: 15px;

                /* Re-center content in the orb */
                display: flex;
                flex-direction: column;
                /* NEW: Need column layout to stack icon and label */
                align-items: center;
                justify-content: center;
                /* Center content vertically */
                padding-top: 0;
            }

            .bottom-nav .nav-item:nth-child(2) .icon {
                font-size: 2.5rem;
                line-height: 1;
            }

            .bottom-nav .nav-item:nth-child(2) .label {
                /* NEW: Removed absolute positioning for contained text */
                position: static;
                width: auto;
                text-align: center;
                font-size: 0.65rem;
                /* Slightly smaller to fit */
                margin-top: 0;
                color: white;
            }

            .bottom-nav .nav-item:nth-child(2):hover {
                background-color: #34495e;
            }

        }

        .primary-icon {
            filter: invert(61%) sepia(14%) saturate(1234%) hue-rotate(350deg) brightness(85%) contrast(89%);
        }

        .secondary-icon {
            filter: invert(88%) sepia(4%) saturate(6809%) hue-rotate(166deg) brightness(102%) contrast(83%);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- The character element, fixed in the center of the viewport --><img id="character" src="images/avatarIdleDown.png" alt="Character">
        
        <!-- NPC Interaction Bubble (Dynamically positioned over NPCs) --><div id="interaction-bubble" class="hidden-bubble">
            Welcome to the open world! Use the D-Pad to explore.
        </div>

        <!-- FIXED NPC 1 (The one that talks) -->
        <img id="npc-fixed" class="npc-avatar" src="images/NPC03.png" alt="Fixed NPC">
        
        <!-- NEW FIXED NPC 2 (The silent companion) -->
        <img id="npc-fixed-companion" class="npc-avatar" src="images/NPC06.png" alt="Fixed NPC Companion">

        <!-- 5 Random NPC Avatars (positioned by JS) --><img id="npc-0" class="npc-avatar" src="images/NPC01.png" alt="NPC 1">
        <img id="npc-1" class="npc-avatar" src="images/NPC02.png" alt="NPC 2">
        <img id="npc-2" class="npc-avatar" src="images/NPC03.png" alt="NPC 3">
        <img id="npc-3" class="npc-avatar" src="images/NPC04.png" alt="NPC 4">
        <img id="npc-4" class="npc-avatar" src="images/NPC05.gif" alt="NPC 5">
        <img id="npc-5" class="npc-avatar" src="images/NPC07.png" alt="NPC 6">
        
        <!-- NEW: Structures/Buildings (Dynamically positioned by JS) -->
        <!-- These are generated by the initializeStructures function in JS -->
    </div>

    <!-- Boundary Warning Bubble (Fixed to viewport edge) --><div id="boundary-warning" class="hidden-boundary">
        End of the World! Turn back traveller.
    </div>

    <div id="controls">
        <!-- The D-Pad buttons --><button id="up-btn">▲</button>
        <div class="hidden-center"></div> 
        <button id="left-btn">◀</button>
        <button id="right-btn">▶</button>
        <button id="down-btn">▼</button>
    </div>

    <nav class="bottom-nav">
        <a href="games.html" class="nav-item">
            <span class="icon"><img src="games.svg" width="50px" class="secondary-icon"></span>
            <span class="label"></span>
        </a>
        <a href="index.html" class="nav-item">
            <span class="icon"><img src="home.svg" width="50px" class="primary-icon"></span>
            <span class="label"></span>
        </a>
        <a href="settings.html" class="nav-item">
            <span class="icon"><img src="settings.svg" width="50px" class="secondary-icon"></span>
            <span class="label"></span>
        </a>
    </nav>

    <!-- JavaScript for Game Logic --><script>
        document.addEventListener('DOMContentLoaded', () => {
            const character = document.getElementById('character');
            const container = document.getElementById('game-container');
            
            // Renamed and New Bubble Elements
            const interactionBubble = document.getElementById('interaction-bubble'); 
            const boundaryWarning = document.getElementById('boundary-warning');

            // --- Game World Configuration ---
            const STEP_SIZE = 30; 
            const WORLD_WIDTH = 3000; 
            const WORLD_HEIGHT = 2000; 
            
            // Character size (80px, must match CSS)
            const CHAR_SIZE = 80; 
            // NEW: Reduced size for character collision box (30x30 centered)
            const CHAR_HITBOX_SIZE = 30; 
            const BUBBLE_OFFSET_Y = 40; 

            // Interaction configuration
            const PROXIMITY_RANGE = 200; 
            
            // Viewport dimensions (initialized here, updated on resize)
            let CONTAINER_WIDTH = container.offsetWidth;
            let CONTAINER_HEIGHT = container.offsetHeight;

            // Global world position tracking (center of the world)
            let worldX = WORLD_WIDTH / 2; 
            let worldY = WORLD_HEIGHT / 2;
            
            let idleTimeout = null; 
            let hasMoved = false; 
            
            // NEW: Variable to hold the continuous movement interval ID
            let movementInterval = null; 

            // --- NPC DATA & INITIALIZATION ---
            
            // Fixed dialogues for customization (UPDATED to include the new NPC dialogue)
            const FIXED_NPC_DIALOGUES = [
                "(Aunty McChina): Longtime! Come in for some nice duck pancakes",
                "(Berryhill Cat): Meow meow meow meow.",
                "(Kebab Man): Sorry, kebab shop is closed",
                "(Police): Let's register your police report",
                "(Crackhead): I would sure love some crack.",
                "(Kaiden): This is my brother Leo",
                // NEW Dialogue for the fixed NPC
                "Great Massaman, even better tea!" 
            ];

            // Helper to get a random coordinate, ensuring it's not too close to the world edge
            function getRandomWorldCoordinate(max) {
                const padding = 150; 
                return Math.floor(Math.random() * (max - CHAR_SIZE - 2 * padding)) + CHAR_SIZE + padding;
            }

            // NPC Avatars, now using fixed dialogues and UPDATED SPRITES
            const NPC_AVATARS = [
                // Fixed NPC 1 (Gatekeeper) - The one that talks (World: 250, 350)
                { id: 'npc-fixed', x: 250, y: 350, dialogue: FIXED_NPC_DIALOGUES[5], sprite: 'images/NPC03.png' }, 
                
                // NEW Fixed NPC 2 (Companion) - 50px left of the first (World: 200, 350). Dialogue is null.
                { id: 'npc-fixed-companion', x: 200, y: 350, dialogue: null, sprite: 'images/NPC06.png' },

                // Existing random NPCs
                { id: 'npc-0', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: FIXED_NPC_DIALOGUES[0], sprite: 'images/NPC01.png' },
                { id: 'npc-1', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: FIXED_NPC_DIALOGUES[1], sprite: 'images/NPC02.png' },
                { id: 'npc-2', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: FIXED_NPC_DIALOGUES[2], sprite: 'images/NPC03.png' },
                { id: 'npc-3', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: FIXED_NPC_DIALOGUES[3], sprite: 'images/NPC04.png' },
                { id: 'npc-4', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: FIXED_NPC_DIALOGUES[4], sprite: 'images/NPC05.gif' },
                { id: 'npc-5', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: FIXED_NPC_DIALOGUES[5], sprite: 'images/NPC07.png' },
            ];

            // --- NEW: STRUCTURE DATA ---
            const STRUCTURES = [
                // Structure 0: Top Left (Large Structure)
                { id: 'structure-0', x: 250, y: 300, width: 180, height: 180, src: 'images/structure01.png' },
                // Structure 1: Bottom Left 1 (Small house)
                { id: 'structure-1', x: 2825, y: 1725, width: 250, height: 300, src: 'images/structure02.png' },
                // Structure 2: Bottom Left 2 (Shop/Market)
                { id: 'structure-2', x: 2700, y: 1350, width: 250, height: 300, src: 'images/structure02.png' },
                // Structure 3: Bottom Left 3 (Tower - Tall)
                { id: 'structure-3', x: 2500, y: 1725, width: 250, height: 300, src: 'images/structure02.png' },
            ];
            
            // --- SPRITE MAPPINGS (Walk sprites updated to GIF) ---
            const IDLE_SPRITES = {
                'up': 'images/avatarIdleUp.png',
                'down': 'images/avatarIdleDown.png',
                'left': 'images/avatarIdleLeft.png',
                'right': 'images/avatarIdleRight.png',
            };

            const WALK_SPRITES = {
                'up': 'images/avatarWalkUp.gif',
                'down': 'images/avatarWalkDown.gif',
                'left': 'images/avatarWalkLeft.gif',
                'right': 'images/avatarWalkRight.gif',
            };
            
            // --- COLLISION LOGIC ---

            /**
             * Creates an AABB (Axis-Aligned Bounding Box) for an entity centered at (x, y).
             * @param {number} x World center X coordinate.
             * @param {number} y World center Y coordinate.
             * @param {number} width Entity width.
             * @param {number} height Entity height.
             * @returns {{left: number, right: number, top: number, bottom: number}}
             */
            function getBoundingBox(x, y, width, height) {
                const halfWidth = width / 2;
                const halfHeight = height / 2;
                return {
                    left: x - halfWidth,
                    right: x + halfWidth,
                    top: y - halfHeight,
                    bottom: y + halfHeight
                };
            }

            /**
             * Performs AABB collision check between two rectangles.
             * @param {Object} rect1 Bounding box 1.
             * @param {Object} rect2 Bounding box 2.
             */
            function checkCollision(rect1, rect2) {
                return (
                    rect1.left < rect2.right &&
                    rect1.right > rect2.left &&
                    rect1.top < rect2.bottom &&
                    rect1.bottom > rect2.top
                );
            }
            
            function setIdleSprite(direction) {
                character.src = IDLE_SPRITES[direction];
            }
            
            /**
             * NEW: Initializes the structure elements in the DOM.
             */
            function initializeStructures() {
                STRUCTURES.forEach(structure => {
                    const img = document.createElement('img');
                    img.id = structure.id;
                    img.className = 'structure-avatar';
                    img.src = structure.src;
                    img.alt = `Structure: ${structure.id}`;
                    img.style.width = `${structure.width}px`;
                    img.style.height = `${structure.height}px`;
                    container.appendChild(img);
                });
            }

            /**
             * Updates the screen position of all NPC avatars based on the camera offset.
             * @param {number} offsetX Camera X offset
             * @param {number} offsetY Camera Y offset
             */
            function updateNPCPositions(offsetX, offsetY) {
                NPC_AVATARS.forEach(npc => {
                    const avatarElement = document.getElementById(npc.id);
                    if (avatarElement) {
                        // Calculate screen coordinates (relative to the game container/viewport)
                        const screenX = npc.x - offsetX - (CHAR_SIZE / 2);
                        const screenY = npc.y - offsetY - (CHAR_SIZE / 2);

                        // Apply screen coordinates to the element
                        avatarElement.style.left = `${screenX}px`;
                        avatarElement.style.top = `${screenY}px`;
                    }
                });
            }

            /**
             * NEW: Updates the screen position of all structures based on the camera offset.
             * @param {number} offsetX Camera X offset
             * @param {number} offsetY Camera Y offset
             */
            function updateStructurePositions(offsetX, offsetY) {
                STRUCTURES.forEach(structure => {
                    const structureElement = document.getElementById(structure.id);
                    if (structureElement) {
                        // Calculate screen coordinates: structure.x/y is the world center coordinate.
                        // We subtract half the structure's width/height to center the image correctly.
                        const screenX = structure.x - offsetX - (structure.width / 2);
                        const screenY = structure.y - offsetY - (structure.height / 2);

                        structureElement.style.left = `${screenX}px`;
                        structureElement.style.top = `${screenY}px`;
                    }
                });
            }


            /**
             * Calculates the screen position of an NPC based on the current camera offset.
             * This function is crucial for positioning the dynamic interaction bubble.
             * @param {Object} npc The NPC object
             * @param {number} offsetX Camera X offset
             * @param {number} offsetY Camera Y offset
             * @returns {{screenX: number, screenY: number}}
             */
            function getNPCScreenPosition(npc, offsetX, offsetY) {
                const screenX = npc.x - offsetX - (CHAR_SIZE / 2);
                const screenY = npc.y - offsetY - (CHAR_SIZE / 2);
                return { screenX, screenY };
            }

            /**
             * Sets the style and content for the boundary warning bubble.
             * @param {string} direction 'top', 'bottom', 'left', 'right'
             */
            function showBoundaryWarning(direction) {
                // Retaining the fixed text from the last request
                boundaryWarning.textContent = 'End of the World! Turn back traveller.';
                
                // Clear all positioning classes
                boundaryWarning.className = '';
                
                // Add the specific direction class to position the warning
                if (direction === 'up') boundaryWarning.classList.add('warning-top');
                else if (direction === 'down') boundaryWarning.classList.add('warning-bottom');
                else if (direction === 'left') boundaryWarning.classList.add('warning-left');
                else if (direction === 'right') boundaryWarning.classList.add('warning-right');
            }

            /**
             * Handles showing dialogue when near an NPC or hitting the boundary.
             */
            function handleInteractions(atBoundaryX, atBoundaryY, offsetX, offsetY) {
                let proximityDetected = false;

                // 1. Check NPC Proximity (A. NPC Check)
                for (const npc of NPC_AVATARS) {
                    // NEW: Only check proximity for NPCs that actually have dialogue
                    if (!npc.dialogue) continue; 
                    
                    const distance = Math.sqrt(
                        (worldX - npc.x) ** 2 + 
                        (worldY - npc.y) ** 2
                    );
                    
                    if (distance < PROXIMITY_RANGE) {
                        proximityDetected = true;
                        
                        // Calculate screen position for the bubble
                        const { screenX, screenY } = getNPCScreenPosition(npc, offsetX, offsetY);
                        
                        // Position bubble over the NPC's head, adjusting for bubble height
                        // screenX + (CHAR_SIZE / 2) targets the horizontal center of the 80px sprite.
                        interactionBubble.style.left = `${screenX + (CHAR_SIZE / 2)}px`;
                        // screenY - BUBBLE_OFFSET_Y targets the position above the sprite.
                        interactionBubble.style.top = `${screenY - BUBBLE_OFFSET_Y}px`; 
                        
                        interactionBubble.textContent = npc.dialogue; 
                        interactionBubble.classList.remove('hidden-bubble');
                        boundaryWarning.classList.add('hidden-boundary'); // Hide boundary warning
                        break; 
                    }
                }

                if (!proximityDetected) {
                    interactionBubble.classList.add('hidden-bubble'); // Hide NPC bubble
                    
                    // 2. Boundary Check (B. Boundary Check)
                    if (atBoundaryX || atBoundaryY) {
                        const minPos = CHAR_SIZE / 2;
                        
                        let direction = '';
                        if (worldY <= minPos) direction = 'up';
                        else if (worldY >= WORLD_HEIGHT - minPos) direction = 'down';
                        else if (worldX <= minPos) direction = 'left';
                        else if (worldX >= WORLD_WIDTH - minPos) direction = 'right';

                        if (direction) {
                            showBoundaryWarning(direction);
                            boundaryWarning.classList.remove('hidden-boundary');
                        }
                    } else if (hasMoved) { 
                        boundaryWarning.classList.add('hidden-boundary'); // Hide warning if away from edge
                    }
                }
            }
            
            /**
             * Updates the game view (background, NPCs, Structures) and runs interaction checks.
             */
            function updateGameView(x, y) {
                const minPos = CHAR_SIZE / 2;
                const maxWorldX = WORLD_WIDTH - minPos;
                const maxWorldY = WORLD_HEIGHT - minPos;
                
                // Determine if the attempted position is hitting a boundary
                const atBoundaryX = (x <= minPos || x >= maxWorldX);
                const atBoundaryY = (y <= minPos || y >= maxWorldY);

                // Clamp the world position to stay within boundaries
                worldX = Math.max(minPos, Math.min(x, maxWorldX));
                worldY = Math.max(minPos, Math.min(y, maxWorldY));
                
                const offsetX = worldX - (CONTAINER_WIDTH / 2);
                const offsetY = worldY - (CONTAINER_HEIGHT / 2);

                // Move the background (camera)
                container.style.backgroundPosition = `${-offsetX}px ${-offsetY}px`;
                
                // Update element positions
                updateNPCPositions(offsetX, offsetY);
                updateStructurePositions(offsetX, offsetY); 
                
                // Run interaction checks
                handleInteractions(atBoundaryX, atBoundaryY, offsetX, offsetY);
            }

            /**
             * Handles initial state setup (called once on load).
             */
            function setInitialState(direction) {
                // Initialize dynamic elements first
                initializeStructures(); 
                
                setIdleSprite(direction);
                // Use the starting position to set up the view and NPCs
                updateGameView(worldX, worldY);
                // Set the initial welcome message in the NPC bubble, correctly positioned above character
                interactionBubble.textContent = "Hey! This isn't Stardew Valley. Where am I?...";
                interactionBubble.style.left = `calc(50% + ${CHAR_SIZE / 2}px)`; // Char center + half char size
                interactionBubble.style.top = `calc(50% - ${CHAR_SIZE / 2 + BUBBLE_OFFSET_Y}px)`; // Char top - offset
                interactionBubble.classList.remove('hidden-bubble');
            }

            /**
             * Handles character movement, position updates, and sprite switching.
             * Collision logic is implemented here.
             */
            function moveCharacter(direction) {
                character.src = WALK_SPRITES[direction];
                clearTimeout(idleTimeout);

                let newWorldX = worldX;
                let newWorldY = worldY;

                // 1. Calculate potential new world position
                switch (direction) {
                    case 'up': newWorldY -= STEP_SIZE; break;
                    case 'down': newWorldY += STEP_SIZE; break;
                    case 'left': newWorldX -= STEP_SIZE; break;
                    case 'right': newWorldX += STEP_SIZE; break;
                }
                
                // 2. Check for collisions at the potential new position
                // MODIFIED: Use the smaller CHAR_HITBOX_SIZE for a more "pixel-like" collision area.
                const potentialCharRect = getBoundingBox(newWorldX, newWorldY, CHAR_HITBOX_SIZE, CHAR_HITBOX_SIZE);
                let collisionDetected = false;

                // Check NPC collisions
                for (const npc of NPC_AVATARS) {
                    // NPC Bounding box remains full size (80x80)
                    const npcRect = getBoundingBox(npc.x, npc.y, CHAR_SIZE, CHAR_SIZE);
                    if (checkCollision(potentialCharRect, npcRect)) {
                        collisionDetected = true;
                        break;
                    }
                }
                
                // Check Structure collisions (only if no NPC collision was found)
                if (!collisionDetected) {
                    for (const structure of STRUCTURES) {
                        // Structure Bounding box remains full size
                        const structureRect = getBoundingBox(structure.x, structure.y, structure.width, structure.height);
                        if (checkCollision(potentialCharRect, structureRect)) {
                            collisionDetected = true;
                            break;
                        }
                    }
                }

                // 3. Update position only if no collision occurred
                if (!collisionDetected) {
                    // Update the entire view and handle clamping/interactions
                    updateGameView(newWorldX, newWorldY);
                } else {
                    // If collision happened, prevent the move but still update the view 
                    // with the current position to handle interactions and boundary checks
                    updateGameView(worldX, worldY); 
                }

                // Set a timeout to revert to the idle sprite
                idleTimeout = setTimeout(() => {
                    setIdleSprite(direction);
                }, 350); 
                
                if (!hasMoved) {
                    hasMoved = true;
                    // Hide the initial welcome message after the first move
                    interactionBubble.classList.add('hidden-bubble');
                }
            }
            
            /**
             * Starts the continuous movement in a given direction when button is pressed.
             * @param {string} direction 'up', 'down', 'left', or 'right'
             */
            function startMovement(direction) {
                // Clear any existing interval to prevent speeding up
                if (movementInterval) {
                    clearInterval(movementInterval);
                }
                
                // 1. Move immediately on press (for quick taps/single step)
                moveCharacter(direction);
                
                // 2. Set interval for continuous movement (100ms for smooth walking)
                movementInterval = setInterval(() => {
                    moveCharacter(direction);
                }, 100); 
            }

            /**
             * Stops the continuous movement when button is released.
             */
            function stopMovement() {
                if (movementInterval) {
                    clearInterval(movementInterval);
                    movementInterval = null;
                }
                // The moveCharacter function already handles setting the idle sprite via timeout.
            }
            
            // Set initial state on load ('down' is the starting direction)
            setInitialState('down');

            // --- Resize Listener ---
            window.addEventListener('resize', () => {
                CONTAINER_WIDTH = container.offsetWidth;
                CONTAINER_HEIGHT = container.offsetHeight;
                updateGameView(worldX, worldY);
            });

            // --- Event Listeners for Buttons (Continuous Movement) ---
            function setupButtonListeners(id, direction) {
                const button = document.getElementById(id);

                // Start movement on press (mouse or touch)
                button.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    startMovement(direction);
                });
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startMovement(direction);
                }, { passive: false });

                // Stop movement on release (mouse or touch)
                button.addEventListener('mouseup', stopMovement);
                button.addEventListener('touchend', stopMovement);
                
                // Stop movement if the mouse cursor leaves the button while held down
                button.addEventListener('mouseleave', stopMovement);
            }
            
            setupButtonListeners('up-btn', 'up');
            setupButtonListeners('down-btn', 'down');
            setupButtonListeners('left-btn', 'left');
            setupButtonListeners('right-btn', 'right');

            // --- Keyboard Controls (WASD or Arrows) ---
            // Note: Keyboard controls only move one step per keypress unless held by the OS repeat
            document.addEventListener('keydown', (event) => {
                let direction = null;
                switch (event.key) {
                    case 'w':
                    case 'ArrowUp':
                        direction = 'up';
                        break;
                    case 's':
                    case 'ArrowDown':
                        direction = 'down';
                        break;
                    case 'a':
                    case 'ArrowLeft':
                        direction = 'left';
                        break;
                    case 'd':
                    case 'ArrowRight':
                        direction = 'right';
                        break;
                }
                if (direction) {
                    event.preventDefault(); 
                    moveCharacter(direction);
                }
            });
            
            // Optional: Prevent double-tap on the entire body using touch events (extra mobile safety)
            let lastTouchTime = 0;
            document.body.addEventListener('touchend', function (event) {
                const now = new Date().getTime();
                if (now - lastTouchTime <= 300) {
                    event.preventDefault();
                }
                lastTouchTime = now;
            }, { passive: false });

        });
    </script>
</body>
</html>