<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- CRITICAL CHANGE: Disables pinch and double-tap zoom on mobile browsers -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Open World D-Pad Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles for full screen and no scrolling */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; 
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* The Game Container (The Viewport) */
        #game-container {
            width: 100vw; 
            height: 100vh; 
            position: relative; 
            overflow: hidden;
            
            /* Camera/World Setup */
            background-image: url('bgs/openWorldBG01.png');
            background-size: 3000px 2000px; 
            background-repeat: no-repeat;
            background-position: 0px 0px; 
            transition: background-position 0.1s linear; /* Smooth scrolling effect */
        }

        /* The Character (Fixed in the Center of the viewport/camera) */
        #character {
            width: 80px; /* INCREASED SIZE */
            height: 80px; /* INCREASED SIZE */
            position: absolute; 
            /* Fixed position: Center of the screen (50% - half of 80px = 40px) */
            top: calc(50% - 40px); 
            left: calc(50% - 40px);
            image-rendering: pixelated; 
            z-index: 10;
        }

        /* NPC Avatar Styling */
        .npc-avatar {
            width: 80px;
            height: 80px;
            position: absolute; 
            z-index: 9; /* Slightly lower than player */
            image-rendering: pixelated; 
            /* NPCs are positioned by JS, no need for transform transition */
        }

        /* Speech Bubble Styling */
        #speech-bubble {
            position: absolute;
            /* Adjusted for 80px character: 50% - (40px character half + ~90px margin/bubble height) */
            top: calc(50% - 130px); 
            left: calc(50% - 75px); 
            width: 150px;
            padding: 8px 12px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #333;
            text-align: center;
            z-index: 15; 
            box-shadow: 2px 2px 0px #333; 
            opacity: 1;
            transition: opacity 0.3s ease-out;
            pointer-events: none; 
        }

        #speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px; 
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid #fff; 
            filter: drop-shadow(0 2px 0px #333); 
        }

        /* Class to hide the bubble */
        .hidden-bubble {
            opacity: 0 !important;
            pointer-events: none !important;
        }


        /* D-Pad Controls (Overlay) */
        #controls {
            position: absolute;
            bottom: 120px; 
            left: 20px;
            z-index: 20;
            user-select: none; 

            /* D-Pad Grid Layout */
            display: grid;
            grid-template-areas:
                ". up ."
                "left center right"
                ". down .";
            grid-template-columns: repeat(3, 80px); 
            grid-template-rows: repeat(3, 80px); 
            gap: 2px;
        }

        #controls button {
            padding: 0;
            height: 100%;
            width: 100%;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            background-color: #4a7a88; 
            border: 3px solid #19282d;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 5px 0 #19282d;
            transition: all 0.05s ease;
        }

        #controls button:active {
            box-shadow: 0 1px 0 #19282d;
            transform: translateY(4px);
            background-color: #5bbdda;
        }

        /* Assign grid areas */
        #up-btn { grid-area: up; }
        #left-btn { grid-area: left; }
        #right-btn { grid-area: right; }
        #down-btn { grid-area: down; }

        /* Hidden element to fill the center of the D-Pad */
        .hidden-center { 
            grid-area: center; 
            visibility: hidden; 
            pointer-events: none;
        } 

        @media (max-width: 768px) {
            .bottom-nav {
                display: flex;
                /* Show for mobile */
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                /* UPDATED: Increased height to 70px */
                height: 70px;
                /* Set the background color */
                background-color: #4a7a88;
                box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                justify-content: space-around;
                align-items: center;

                /* MODIFIED: Changed margin to padding for empty space at the very bottom */
                padding-bottom: 10px;
            }

            .nav-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-decoration: none;
                color: white;
                /* Text color */
                flex-grow: 1;
                /* Retained flex-grow for side items */
                height: 100%;
                font-size: 0.75rem;
                /* Smaller font for mobile labels */
                transition: background-color 0.2s;
                background-color: transparent;
            }

            .nav-item:hover {
                background-color: #34495e;
            }

            .nav-item .icon {
                font-size: 1.5rem;
                line-height: 1;
                /* Keep icon vertically centered */
            }

            .nav-item .label {
                margin-top: 3px;
                font-family: 'Pixelify Sans', sans-serif;
            }

            /* REVISED CSS for the perfect circle orb icon */
            .bottom-nav .nav-item:nth-child(2) {
                /* Selects the second nav-item (the middle one) */
                position: relative;
                /* Adjusted top to keep the orb visually centered on the bar (70px high + 10px pad) */
                top: -20px;

                /* UPDATED: Orb size */
                width: 80px;
                height: 80px;
                border-radius: 15%;

                /* Ensures same color as navbar */
                background-color: #d9a56b;

                box-shadow: 0 -5px 10px rgba(0, 0, 0, 0.3);

                /* Overrides default nav-item flex properties to ensure fixed size */
                flex-grow: 0;
                flex-shrink: 0;
                flex-basis: auto;

                /* Margin adjustments to visually separate the side items from the orb */
                margin-left: 15px;
                margin-right: 15px;

                /* Re-center content in the orb */
                display: flex;
                flex-direction: column;
                /* NEW: Need column layout to stack icon and label */
                align-items: center;
                justify-content: center;
                /* Center content vertically */
                padding-top: 0;
            }

            .bottom-nav .nav-item:nth-child(2) .icon {
                font-size: 2.5rem;
                line-height: 1;
            }

            .bottom-nav .nav-item:nth-child(2) .label {
                /* NEW: Removed absolute positioning for contained text */
                position: static;
                width: auto;
                text-align: center;
                font-size: 0.65rem;
                /* Slightly smaller to fit */
                margin-top: 0;
                color: white;
            }

            .bottom-nav .nav-item:nth-child(2):hover {
                background-color: #34495e;
            }

        }

        .primary-icon {
            filter: invert(61%) sepia(14%) saturate(1234%) hue-rotate(350deg) brightness(85%) contrast(89%);
        }

        .secondary-icon {
            filter: invert(88%) sepia(4%) saturate(6809%) hue-rotate(166deg) brightness(102%) contrast(83%);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- The character element, fixed in the center of the viewport --><img id="character" src="images/avatarIdleDown.png" alt="Character">
        
        <!-- Speech Bubble (now used for dynamic messages) --><div id="speech-bubble" class="hidden-bubble">
            Hey! This isn't Stardew Valley. Seems like I'm in a fantasy forest though...
        </div>

        <!-- 5 NPC Avatars (positioned by JS) -->
        <img id="npc-0" class="npc-avatar" src="images/avatarIdleUp.png" alt="NPC 1">
        <img id="npc-1" class="npc-avatar" src="images/avatarIdleLeft.png" alt="NPC 2">
        <img id="npc-2" class="npc-avatar" src="images/avatarIdleRight.png" alt="NPC 3">
        <img id="npc-3" class="npc-avatar" src="images/avatarIdleDown.png" alt="NPC 4">
        <img id="npc-4" class="npc-avatar" src="images/avatarIdleUp.png" alt="NPC 5">
    </div>

    <div id="controls">
        <!-- The D-Pad buttons --><button id="up-btn">▲</button>
        <div class="hidden-center"></div> 
        <button id="left-btn">◀</button>
        <button id="right-btn">▶</button>
        <button id="down-btn">▼</button>
    </div>

    <nav class="bottom-nav">
        <a href="games.html" class="nav-item">
            <span class="icon"><img src="games.svg" width="50px" class="secondary-icon"></span>
            <span class="label"></span>
        </a>
        <a href="index.html" class="nav-item">
            <span class="icon"><img src="home.svg" width="50px" class="primary-icon"></span>
            <span class="label"></span>
        </a>
        <a href="settings.html" class="nav-item">
            <span class="icon"><img src="settings.svg" width="50px" class="secondary-icon"></span>
            <span class="label"></span>
        </a>
    </nav>

    <!-- JavaScript for Game Logic --><script>
        document.addEventListener('DOMContentLoaded', () => {
            const character = document.getElementById('character');
            const container = document.getElementById('game-container');
            const speechBubble = document.getElementById('speech-bubble');
            
            // --- Game World Configuration ---
            const STEP_SIZE = 30; // Movement speed in pixels
            const WORLD_WIDTH = 3000; 
            const WORLD_HEIGHT = 2000; 
            
            // Character size (80px, must match CSS)
            const CHAR_SIZE = 80; 
            
            // Interaction configuration
            const PROXIMITY_RANGE = 200; // Distance in pixels to trigger speech bubble
            
            // Viewport dimensions (initialized here, updated on resize)
            let CONTAINER_WIDTH = container.offsetWidth;
            let CONTAINER_HEIGHT = container.offsetHeight;

            // Global world position tracking (center of the world)
            let worldX = WORLD_WIDTH / 2; 
            let worldY = WORLD_HEIGHT / 2;
            
            let idleTimeout = null; 
            let hasMoved = false; // Flag for first movement

            // --- NPC DATA & INITIALIZATION ---
            const NPC_DIALOGUES = [
                "Hello traveler! The path ahead is rocky.",
                "Did you see a blue butterfly? It was huge!",
                "I'm just watching the grass grow today.",
                "I hear rumors of an ancient ruin to the East...",
                "Beware the quicksand near the river!",
                "Lost my keys again. Oh well."
            ];

            // Helper to get a random coordinate, ensuring it's not too close to the world edge
            function getRandomWorldCoordinate(max) {
                return Math.floor(Math.random() * (max - CHAR_SIZE)) + CHAR_SIZE;
            }

            // Helper to get 3 random unique dialogues for an NPC
            function getDialogue() {
                let dialogues = [];
                const pool = [...NPC_DIALOGUES];
                for (let i = 0; i < 3; i++) {
                    const index = Math.floor(Math.random() * pool.length);
                    dialogues.push(pool.splice(index, 1)[0]);
                }
                return dialogues;
            }

            const NPC_AVATARS = [
                { id: 'npc-0', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: getDialogue(), sprite: 'images/avatarIdleUp.png' },
                { id: 'npc-1', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: getDialogue(), sprite: 'images/avatarIdleLeft.png' },
                { id: 'npc-2', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: getDialogue(), sprite: 'images/avatarIdleRight.png' },
                { id: 'npc-3', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: getDialogue(), sprite: 'images/avatarIdleDown.png' },
                { id: 'npc-4', x: getRandomWorldCoordinate(WORLD_WIDTH), y: getRandomWorldCoordinate(WORLD_HEIGHT), dialogue: getDialogue(), sprite: 'images/avatarIdleUp.png' },
            ];
            
            // --- SPRITE MAPPINGS (Corrected walk sprites) ---
            const IDLE_SPRITES = {
                'up': 'images/avatarIdleUp.png',
                'down': 'images/avatarIdleDown.png',
                'left': 'images/avatarIdleLeft.png',
                'right': 'images/avatarIdleRight.png',
            };

            const WALK_SPRITES = {
                // IMPORTANT: Fixed the bug where the walk sprites were referencing the idle images.
                'up': 'images/avatarWalkUp.gif',
                'down': 'images/avatarWalkDown.gif',
                'left': 'images/avatarWalkLeft.gif',
                'right': 'images/avatarWalkRight.gif',
            };

            function setIdleSprite(direction) {
                character.src = IDLE_SPRITES[direction];
            }
            
            /**
             * Updates the visual position of all NPCs based on the camera offset.
             */
            function updateNPCPositions(offsetX, offsetY) {
                NPC_AVATARS.forEach(npc => {
                    const element = document.getElementById(npc.id);
                    if (element) {
                        // NPC position relative to the viewport: World position - Camera offset - half of NPC size
                        const screenX = npc.x - offsetX - (CHAR_SIZE / 2);
                        const screenY = npc.y - offsetY - (CHAR_SIZE / 2);

                        element.style.left = `${screenX}px`;
                        element.style.top = `${screenY}px`;
                        element.src = npc.sprite; // Ensure they keep their designated idle sprite
                    }
                });
            }

            /**
             * Handles showing dialogue when near an NPC or hitting the boundary.
             */
            function handleInteractions(atBoundaryX, atBoundaryY) {
                let showBubble = false;
                let message = "";
                let proximityDetected = false;

                // A. NPC Proximity Check
                for (const npc of NPC_AVATARS) {
                    // Distance between character center and NPC center
                    const distance = Math.sqrt(
                        (worldX - npc.x) ** 2 + 
                        (worldY - npc.y) ** 2
                    );
                    
                    if (distance < PROXIMITY_RANGE) {
                        // Pick a random dialogue from the NPC's dialogue pool
                        const index = Math.floor(Math.random() * npc.dialogue.length);
                        message = `NPC #${npc.id.slice(-1)} says: ${npc.dialogue[index]}`;
                        showBubble = true;
                        proximityDetected = true;
                        break; // Only show one NPC dialogue at a time
                    }
                }
                
                // B. Boundary Check (only if no NPC is nearby)
                if (!proximityDetected && (atBoundaryX || atBoundaryY)) {
                    message = "End of the World! Turn back now, adventurer.";
                    showBubble = true;
                }

                // C. Update Speech Bubble UI
                if (showBubble) {
                    speechBubble.textContent = message;
                    speechBubble.classList.remove('hidden-bubble');
                } else if (hasMoved) { 
                    // Only hide the bubble if the player is not interacting and has moved once
                    speechBubble.classList.add('hidden-bubble');
                }
            }
            
            /**
             * Updates the game view (background, NPCs) and runs interaction checks.
             */
            function updateGameView(x, y) {
                const minPos = CHAR_SIZE / 2;
                const maxWorldX = WORLD_WIDTH - minPos;
                const maxWorldY = WORLD_HEIGHT - minPos;
                
                // Determine if the attempted position is hitting a boundary
                const atBoundaryX = (x <= minPos || x >= maxWorldX);
                const atBoundaryY = (y <= minPos || y >= maxWorldY);

                // Clamp the world position to stay within boundaries
                worldX = Math.max(minPos, Math.min(x, maxWorldX));
                worldY = Math.max(minPos, Math.min(y, maxWorldY));
                
                const offsetX = worldX - (CONTAINER_WIDTH / 2);
                const offsetY = worldY - (CONTAINER_HEIGHT / 2);

                // Move the background (camera)
                container.style.backgroundPosition = `${-offsetX}px ${-offsetY}px`;
                
                // Update NPC positions
                updateNPCPositions(offsetX, offsetY);
                
                // Run interaction checks
                handleInteractions(atBoundaryX, atBoundaryY);
            }

            /**
             * Handles initial state setup (called once on load).
             */
            function setInitialState(direction) {
                setIdleSprite(direction);
                // Use the starting position to set up the view and NPCs
                updateGameView(worldX, worldY);
                // Set the initial welcome message
                speechBubble.textContent = "Hey! This isn't Stardew Valley. Where am I?";
                speechBubble.classList.remove('hidden-bubble');
            }

            /**
             * Handles character movement, position updates, and sprite switching.
             */
            function moveCharacter(direction) {
                // 1. Set the walking sprite immediately
                character.src = WALK_SPRITES[direction];
                
                clearTimeout(idleTimeout);

                let newWorldX = worldX;
                let newWorldY = worldY;

                // Calculate potential new world position
                switch (direction) {
                    case 'up':
                        newWorldY -= STEP_SIZE;
                        break;
                    case 'down':
                        newWorldY += STEP_SIZE;
                        break;
                    case 'left':
                        newWorldX -= STEP_SIZE;
                        break;
                    case 'right':
                        newWorldX += STEP_SIZE;
                        break;
                }
                
                // Update the entire view and handle clamping/interactions
                updateGameView(newWorldX, newWorldY);

                // 3. Set a timeout to revert to the idle sprite
                idleTimeout = setTimeout(() => {
                    setIdleSprite(direction);
                }, 350); 
                
                // Set flag after first movement
                if (!hasMoved) {
                    hasMoved = true;
                }
            }
            
            // Set initial state on load ('down' is the starting direction)
            setInitialState('down');

            // --- Resize Listener (keeps the character centered when the viewport changes) ---
            window.addEventListener('resize', () => {
                CONTAINER_WIDTH = container.offsetWidth;
                CONTAINER_HEIGHT = container.offsetHeight;
                // Recalculate view based on new container size
                updateGameView(worldX, worldY);
            });

            // --- Event Listeners for Buttons ---
            // e.preventDefault() added to prevent potential mobile issues with buttons
            document.getElementById('up-btn').addEventListener('click', (e) => { e.preventDefault(); moveCharacter('up'); });
            document.getElementById('down-btn').addEventListener('click', (e) => { e.preventDefault(); moveCharacter('down'); });
            document.getElementById('left-btn').addEventListener('click', (e) => { e.preventDefault(); moveCharacter('left'); });
            document.getElementById('right-btn').addEventListener('click', (e) => { e.preventDefault(); moveCharacter('right'); });
            
            // --- Keyboard Controls (WASD or Arrows) ---
            document.addEventListener('keydown', (event) => {
                let direction = null;
                switch (event.key) {
                    case 'w':
                    case 'ArrowUp':
                        direction = 'up';
                        break;
                    case 's':
                    case 'ArrowDown':
                        direction = 'down';
                        break;
                    case 'a':
                    case 'ArrowLeft':
                        direction = 'left';
                        break;
                    case 'd':
                    case 'ArrowRight':
                        direction = 'right';
                        break;
                }
                if (direction) {
                    event.preventDefault(); 
                    moveCharacter(direction);
                }
            });
            
            // Optional: Prevent double-tap on the entire body using touch events (extra mobile safety)
            let lastTouchTime = 0;
            document.body.addEventListener('touchend', function (event) {
                const now = new Date().getTime();
                if (now - lastTouchTime <= 300) {
                    event.preventDefault();
                }
                lastTouchTime = now;
            }, { passive: false });

        });
    </script>
</body>
</html>